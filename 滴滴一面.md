# JavaScript 前端面试题整理

## 一、数据类型

### JavaScript 数据类型分类

| 类型 | 分类 |
|------|------|
| number | 基础数据类型 |
| string | 基础数据类型 |
| boolean | 基础数据类型 |
| undefined | 基础数据类型 |
| null | 基础数据类型 |
| symbol | 基础数据类型 |
| bigint | 基础数据类型 |
| object | 引用数据类型 |

## 二、数据类型检测方法

### 1. typeof

```javascript
typeof 2              // "number"
typeof true           // "boolean"
typeof "str"          // "string"
typeof []             // "object"
typeof function(){}   // "function"
typeof {}             // "object"
typeof undefined      // "undefined"
typeof null           // "object" (特殊情况)
```

### 2. instanceof

```javascript
// 基本用法
[] instanceof Array                    // true
{} instanceof Object                   // true
function(){} instanceof Function       // true

// 字面量基础类型
"str" instanceof String               // false
123 instanceof Number                 // false
true instanceof Boolean               // false

// 构造函数创建的对象
new String("str") instanceof String   // true
new Number(123) instanceof Number     // true
new Boolean(true) instanceof Boolean  // true

// 原型链检测
[] instanceof Object                  // true (Array继承自Object)
new Date() instanceof Object          // true

// 特殊情况
null instanceof Object                // false
undefined instanceof Object           // false
```

**instanceof 特点：**
- 对于字面量的基础数据类型返回 false
- 对于构造函数创建的对象返回 true
- 会沿着原型链查找
- null 和 undefined 对任何类型都返回 false

### 3. Object.prototype.toString.call

```javascript
Object.prototype.toString.call(2)              // "[object Number]"
Object.prototype.toString.call(true)           // "[object Boolean]"
Object.prototype.toString.call("str")          // "[object String]"
Object.prototype.toString.call([])             // "[object Array]"
Object.prototype.toString.call(function(){})   // "[object Function]"
Object.prototype.toString.call({})             // "[object Object]"
Object.prototype.toString.call(undefined)      // "[object Undefined]"
Object.prototype.toString.call(null)           // "[object Null]"
```

### 4. constructor

```javascript
(2).constructor === Number              // true
true.constructor === Boolean            // true
"str".constructor === String            // true
[].constructor === Array                // true
function(){}.constructor === Function   // true
{}.constructor === Object               // true

// 注意：null 和 undefined 没有 constructor 属性
// null.constructor      // TypeError
// undefined.constructor // TypeError
```

## 三、this 指向

### 箭头函数 vs 普通函数的 this

- **箭头函数**：捕获上下文的 this，在定义时确定
- **普通函数**：谁调用指向谁，在运行时确定

### 普通函数 this 指向规则

```javascript
// 1. 对象方法调用 - 指向调用对象
const obj = {
  name: "pbj",
  fn: function() {
    console.log(this.name); // "pbj"
  }
};
obj.fn();

// 2. 普通函数调用 - 指向 window
function fn() {
  console.log(this); // window
}
fn();

// 3. 构造函数调用 - 指向实例对象
function Person(name) {
  this.name = name;
}
const p = new Person("李白");
console.log(p.name); // "李白"

// 4. call/apply/bind - 指向指定对象
function fng() {
  console.log(this.name);
}
const objg = { name: "pj" };
fng.call(objg);   // "pj"
fng.apply(objg);  // "pj"
fng.bind(objg)(); // "pj"

// 5. 事件处理器 - 指向触发事件的元素
// const btn = document.querySelector("#btn");
// btn.addEventListener("click", function () {
//   console.log(this); // btn 元素
// });

// 6. new 中的 this - 指向新创建的实例对象
function newFn(params) {
  this.name = params;
  console.log(this); // 新创建的对象
}
const np = new newFn("pbj");
```

## 四、闭包

### 定义
闭包 = 函数 + 其创建时所捕获的词法作用域

### 形成条件
1. 函数嵌套，内部函数访问外部变量
2. 内部函数被导出到外部作用域（返回值或回调函数）

### 特点
1. 变量私有化
2. 不会被垃圾回收机制回收

## 五、事件循环机制

### 组成部分
1. **调用栈 (Call Stack)**
2. **任务队列 (Task Queue)** - 存放宏任务
3. **微任务队列 (Microtask Queue)** - 存放微任务

### 任务分类

**宏任务 (Macrotask)：**
- script（整体代码）
- setTimeout
- setInterval
- I/O 操作
- UI 绘制
- 事件处理函数

**微任务 (Microtask)：**
- Promise.then()
- MutationObserver
- process.nextTick()
- queueMicrotask()

### 执行流程
1. 同步任务在调用栈中执行
2. 遇到异步任务时，分别放入对应的任务队列
3. 调用栈为空时，优先执行微任务队列中的所有任务
4. 微任务队列为空时，执行一个宏任务
5. 重复步骤 3 和 4

### 经典示例

```javascript
console.log('任务队列示例');

setTimeout(function () {
    console.log(1);          // 宏任务
});

new Promise(function(resolve,reject){
    console.log(2)           // 同步任务！
    resolve(3)               // 同步任务
}).then(function(val){
    console.log(val);        // 微任务
})

new Promise(function(resolve,reject){
    console.log(6)           // 同步任务！
    resolve(7)               // 同步任务
}).then(function(val){
    console.log(val);        // 微任务
})

console.log(4);              // 同步任务

// 输出顺序：任务队列示例 → 2 → 6 → 4 → 3 → 7 → 1
```

### 常见陷阱

1. **Promise 构造函数是同步执行的**
   ```javascript
   console.log('start');
   new Promise((resolve) => {
     console.log('Promise executor'); // 立即执行
     resolve();
   }).then(() => {
     console.log('Promise then'); // 微任务
   });
   console.log('end');
   // 输出：start → Promise executor → end → Promise then
   ```

2. **async 函数中 await 之前的代码是同步执行**
   ```javascript
   async function async1() {
     console.log('async1 start');
     await async2();
     console.log('async1 end');
   }
   
   async function async2() {
     console.log('async2');
   }
   
   console.log('script start');
   async1();
   console.log('script end');
   // 输出：script start → async1 start → async2 → script end → async1 end
   ```

3. **微任务总是优先于宏任务**
   ```javascript
   console.log('1');
   setTimeout(() => console.log('2'), 0);
   Promise.resolve().then(() => {
     console.log('3');
     setTimeout(() => console.log('4'), 0);
     Promise.resolve().then(() => console.log('5'));
   });
   console.log('6');
   // 输出：1 → 6 → 3 → 5 → 2 → 4
   ```

4. **已经 resolved 的 Promise 仍然会进入微任务队列**
   ```javascript
   console.log('start');
   const resolvedPromise = Promise.resolve('resolved');
   resolvedPromise.then(value => {
     console.log(value);
   });
   console.log('end');
   // 输出：start → end → resolved
   ```

## 六、手写实现

### 1. Promise.retry 实现

```javascript
Promise.retry = function (fn, times) {
  return new Promise((resolve, reject) => {
    fn()
      .then(resolve)
      .catch((err) => {
        if (times > 0) {
          Promise.retry(fn, times - 1)
            .then(resolve)
            .catch(reject);
        } else {
          reject(err);
        }
      });
  });
};

// 使用示例
const mockRequest = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log("mock 请求");
      reject(); // 模拟请求失败
    }, 500);
  });
};

Promise.retry(mockRequest, 3)
  .then(() => {
    console.log("成功");
  })
  .catch((err) => {
    console.log("重试3次失败", err);
  });
```

### 2. 防抖 (Debounce)

```javascript
function debounce(fn, delay) {
  let timer = null;
  return function (...args) {
    const context = this;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, delay);
  };
}
```

**特点：**
- 多次触发只执行最后一次
- 通过 clearTimeout 取消前面的执行
- 常用于搜索、resize 等场景

### 3. 节流 (Throttle)

#### 时间戳版本
```javascript
function throttle(fn, delay) {
  let lastTime = 0;
  return function (...args) {
    const context = this;
    const nowTime = Date.now();
    if (nowTime - lastTime > delay) {
      lastTime = nowTime;
      return fn.apply(context, args);
    }
  };
}
```

#### 定时器版本
```javascript
function throttle2(fn, delay) {
  let timer = null;
  return function (...args) {
    const context = this;
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      fn.apply(context, args);
      timer = null;
    }, delay);
  };
}
```

**特点：**
- 每隔一定时间触发一次
- 通过时间间隔或定时器控制执行频率
- 常用于滚动、拖拽等场景

## 七、循环与递归

### 等价性
在图灵完备的编程语言中，循环和递归是等价的，可以相互转换。

### 区别对比

| 方面 | 循环 | 递归 |
|------|------|------|
| 实现方式 | 反复跳转到同一段代码 | 函数反复调用自身 |
| 内存使用 | 常数额外空间 | O(n) 空间（调用栈） |
| 性能 | 更快，无函数调用开销 | 有函数调用开销 |
| 可读性 | 适合重复固定次数的问题 | 适合分治、树形结构问题 |
| 终止控制 | 通过修改循环条件或计数器 | 通过基例（base case）判断 |
| 风险 | 无限循环 | 栈溢出 |
| 尾递归优化 | 不需要 | 某些语言可优化为循环 |

### 示例对比：计算阶乘

```javascript
// 循环版本
function factorialIterative(n) {
  if (n < 0) return "请输入非负整数";
  let result = 1;
  for (let i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}

// 递归版本
function factorialRecursive(n) {
  if (n < 0) return "请输入非负整数";
  if (n === 0 || n === 1) return 1;
  return n * factorialRecursive(n - 1);
}
```

## 总结

- **只要有判断和次数控制，就能实现循环和递归**，两者在计算能力上等价
- **区别主要在实现机制、可读性、内存占用和适用场景**：
  - 循环更高效、节省内存，适合简单重复
  - 递归更优雅、自然，适合分治和树形问题，但要注意栈溢出风险

---

**作者**: an31742  
**邮箱**: 2234170284@qq.com  
**最后更新**: 2025-01-27