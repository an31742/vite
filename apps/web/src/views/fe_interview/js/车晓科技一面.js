// 简单的介绍一下自己。
// 拿你最印象最深的项目讲一下。
// 唯一的watch和company有什么区别？
// 介绍一下webpack是如何编译的？
// 讲一下promise有什么优缺点？
// 讲一下i frame有什么优缺点？
// 讲一下性能优化
// 关于移动端的项目讲一下。
// 讲一下你对加班有什么看法？
// 有什么提问的吗？其实问的是上线时间。


// watch和company有什么区别
console.log("🚀 ~ watch和company有什么区别:")
// 方面, computed（计算属性）, watch（监听器）
// 核心用途,根据依赖的数据计算出一个新值（衍生数据），像一个“智能变量”。适合模板中直接使用。,监听特定数据的变化，当变化时执行自定义操作（副作用）。
// 是否有缓存,有缓存：依赖数据未变时，直接返回缓存值，不重新计算（性能更好）。,无缓存：每次数据变化都重新执行回调。
// 是否需要 return,必须返回一个值（getter 默认返回计算结果）。,不需要 return，可执行任意逻辑（如异步操作）。
// 执行时机,依赖数据变化时懒执行；首次访问时计算。,数据变化时立即执行（可配置 immediate 为 true 首次执行）。
// 支持异步,不支持（纯同步计算）。,支持（回调中可做 API 请求等异步操作）。
// 场景示例,多对一：如 fullName = firstName + lastName；购物车总价计算。,一对多：搜索关键词变化时发请求；路由变化时加载数据。
// 深度监听,自动追踪依赖，无需手动配置 deep。,需要手动加 { deep: true } 监听对象内部变化。
// 性能考虑,优先用 computed（缓存优势）。,适合复杂逻辑，但滥用可能导致性能问题。

// webpack是如何编译的
console.log("🚀 ~ webpack是如何编译的:")

// 1. 初始化阶段
// 读取配置文件（webpack.config.js）

// 合并命令行参数和配置文件

// 初始化 Compiler 对象

// 2. 编译阶段
// 入口解析：从 entry 开始分析依赖

// 模块解析：递归分析所有依赖模块

// Loader 处理：使用对应 loader 转换文件

// AST 解析：生成抽象语法树，提取依赖关系

// 3. 构建阶段
// 依赖图构建：建立完整的模块依赖图

// 代码转换：ES6+ → ES5，TypeScript → JavaScript

// 资源处理：图片、CSS 等静态资源

// 4. 优化阶段
// Tree Shaking：移除未使用代码

// 代码分割：按需加载，提取公共模块

// 压缩混淆：UglifyJS、Terser 压缩代码

// 5. 输出阶段
// 生成 chunks：将模块组合成代码块

// 生成 bundle：输出最终的打包文件

// 写入文件系统：输出到 dist 目录

//promise有什么优缺点
console.log("promise有什么优缺点");
// 优点
// 解决回调地狱：链式调用，代码更清晰

// 更好的错误处理：统一的 .catch() 处理异常

// 状态不可逆：pending → fulfilled/rejected，避免状态混乱

// 支持并发：Promise.all()、Promise.race() 等方法

// 标准化：ES6 原生支持，API 统一


// 缺点
// 无法取消：一旦创建就会执行，无法中途取消

// 单一值：只能返回一个值，不支持多个值

// 立即执行：创建时立即执行，不是惰性的

// 调试困难：异步栈追踪复杂

// 内存泄漏风险：长时间 pending 可能导致内存问题

// iframe的优缺点
console.log("🚀 ~ iframe的优缺点:")
// 优点
// 隔离性：独立的文档环境，样式和脚本不会相互影响

// 安全性：沙箱机制，防止恶意代码影响主页面

// 复用性：可以嵌入第三方页面（地图、视频、广告等）

// 独立加载：不影响主页面的加载和渲染

// 跨域嵌入：可以嵌入不同域名的内容


// 缺点
// SEO 不友好：搜索引擎难以索引 iframe 内容

// 性能开销：额外的 HTTP 请求和内存消耗

// 响应式困难：难以适配不同屏幕尺寸

// 通信复杂：父子页面通信需要 postMessage

// 用户体验差：

// 浏览器前进后退按钮可能失效

// 页面滚动和焦点管理复杂

// 移动端兼容性问题

// 性能优化
console.log("🚀 ~ 性能优化:")

// 1. 加载优化
// 代码分割：按需加载，减少首屏包体积

// 懒加载：图片、组件延迟加载

// 预加载：<link rel="preload"> 关键资源

// CDN：静态资源使用 CDN 加速

// 压缩：Gzip/Brotli 压缩，代码混淆


// 2. 渲染优化
// 虚拟滚动：大列表性能优化

// 防抖节流：减少高频事件触发

// 避免重排重绘：批量 DOM 操作

// CSS 优化：避免复杂选择器，使用 transform

// 3. 缓存优化
// HTTP 缓存：设置合理的 Cache-Control

// 浏览器缓存：localStorage、sessionStorage

// Service Worker：离线缓存

// 内存缓存：组件级缓存，避免重复计算


// 4. 网络优化
// HTTP/2：多路复用，减少请求延迟

// 减少请求：合并文件，雪碧图

// 接口优化：数据分页，字段精简

// 并发控制：限制同时请求数量

// 5. Vue 特定优化
// v-show vs v-if：频繁切换用 v-show

// key 优化：列表渲染使用唯一 key

// computed 缓存：利用计算属性缓存

// 组件懒加载：路由级别的代码分割